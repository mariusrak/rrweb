{"version":3,"file":"rrweb.min.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/rrweb-snapshot/es/rrweb-snapshot.js","../src/utils.ts","../src/types.ts","../src/record/observer.ts","../src/record/collection.ts","../src/record/index.ts","../node_modules/mitt/dist/mitt.es.js","../node_modules/smoothscroll-polyfill/dist/smoothscroll.js","../src/replay/timer.ts","../src/replay/styles/inject-style.ts","../src/replay/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","var NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nvar _id = 1;\nfunction genId() {\n    return _id++;\n}\nfunction resetId() {\n    _id = 1;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules\n            ? Array.from(rules).reduce(function (prev, cur) { return (prev += cur.cssText); }, '')\n            : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction extractOrigin(url) {\n    var origin;\n    if (url.indexOf('//') > -1) {\n        origin = url\n            .split('/')\n            .slice(0, 3)\n            .join('/');\n    }\n    else {\n        origin = url.split('/')[0];\n    }\n    origin = origin.split('?')[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:'([^']*)'|\"([^\"]*)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/).*/;\nvar DATA_URI = /^(data:)([\\w\\/\\+]+);(charset=[\\w-]+|base64).*,(.*)/gi;\nfunction absoluteToStylesheet(cssText, href) {\n    return cssText.replace(URL_IN_CSS_REF, function (origin, path1, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        if (!filePath) {\n            return origin;\n        }\n        if (!RELATIVE_PATH.test(filePath)) {\n            return \"url('\" + filePath + \"')\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + filePath + \")\";\n        }\n        if (filePath[0] === '/') {\n            return \"url('\" + (extractOrigin(href) + filePath) + \"')\";\n        }\n        var stack = href.split('/');\n        var parts = filePath.split('/');\n        stack.pop();\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            if (part === '.') {\n                continue;\n            }\n            else if (part === '..') {\n                stack.pop();\n            }\n            else {\n                stack.push(part);\n            }\n        }\n        return \"url('\" + stack.join('/') + \"')\";\n    });\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    var a = doc.createElement('a');\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\nvar BLOCK_CLASS = 'rr-block';\nfunction serializeNode(n, doc) {\n    switch (n.nodeType) {\n        case n.DOCUMENT_NODE:\n            return {\n                type: NodeType.Document,\n                childNodes: []\n            };\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId\n            };\n        case n.ELEMENT_NODE:\n            var needBlock = n.classList.contains(BLOCK_CLASS);\n            var tagName = n.tagName.toLowerCase();\n            var attributes_1 = {};\n            for (var _i = 0, _a = Array.from(n.attributes); _i < _a.length; _i++) {\n                var _b = _a[_i], name = _b.name, value = _b.value;\n                if (name === 'src' || name === 'href') {\n                    attributes_1[name] = absoluteToDoc(doc, value);\n                }\n                else if (name === 'style') {\n                    attributes_1[name] = absoluteToStylesheet(value, location.href);\n                }\n                else {\n                    attributes_1[name] = value;\n                }\n            }\n            if (tagName === 'link') {\n                var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n                    return s.href === n.href;\n                });\n                var cssText = getCssRulesString(stylesheet);\n                if (cssText) {\n                    attributes_1 = {\n                        _cssText: absoluteToStylesheet(cssText, stylesheet.href)\n                    };\n                }\n            }\n            if (tagName === 'input' ||\n                tagName === 'textarea' ||\n                tagName === 'select') {\n                var value = n.value;\n                if (attributes_1.type !== 'radio' &&\n                    attributes_1.type !== 'checkbox' &&\n                    value) {\n                    attributes_1.value = value;\n                }\n                else if (n.checked) {\n                    attributes_1.checked = n.checked;\n                }\n            }\n            if (tagName === 'option') {\n                var selectValue = n.parentElement;\n                if (attributes_1.value === selectValue.value) {\n                    attributes_1.selected = n.selected;\n                }\n            }\n            if (needBlock) {\n                var _c = n.getBoundingClientRect(), width = _c.width, height = _c.height;\n                attributes_1.rr_width = width + \"px\";\n                attributes_1.rr_height = height + \"px\";\n            }\n            return {\n                type: NodeType.Element,\n                tagName: tagName,\n                attributes: attributes_1,\n                childNodes: [],\n                isSVG: isSVGElement(n) || undefined,\n                needBlock: needBlock\n            };\n        case n.TEXT_NODE:\n            var parentTagName = n.parentNode && n.parentNode.tagName;\n            var textContent = n.textContent;\n            var isStyle = parentTagName === 'STYLE' ? true : undefined;\n            if (isStyle && textContent) {\n                textContent = absoluteToStylesheet(textContent, location.href);\n            }\n            if (parentTagName === 'SCRIPT') {\n                textContent = 'SCRIPT_PLACEHOLDER';\n            }\n            return {\n                type: NodeType.Text,\n                textContent: textContent || '',\n                isStyle: isStyle\n            };\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: ''\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || ''\n            };\n        default:\n            return false;\n    }\n}\nfunction serializeNodeWithId(n, doc, map, skipChild) {\n    if (skipChild === void 0) { skipChild = false; }\n    var _serializedNode = serializeNode(n, doc);\n    if (!_serializedNode) {\n        console.warn(n, 'not serialized');\n        return null;\n    }\n    var serializedNode = Object.assign(_serializedNode, {\n        id: genId()\n    });\n    n.__sn = serializedNode;\n    map[serializedNode.id] = n;\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n    }\n    if ((serializedNode.type === NodeType.Document ||\n        serializedNode.type === NodeType.Element) &&\n        recordChild) {\n        for (var _i = 0, _a = Array.from(n.childNodes); _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var serializedChildNode = serializeNodeWithId(childN, doc, map);\n            if (serializedChildNode) {\n                serializedNode.childNodes.push(serializedChildNode);\n            }\n        }\n    }\n    return serializedNode;\n}\nfunction snapshot(n) {\n    resetId();\n    var idNodeMap = {};\n    return [serializeNodeWithId(n, n, idNodeMap), idNodeMap];\n}\n\nvar tagMap = {\n    script: 'noscript',\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    fedropshadow: 'feDropShadow',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient'\n};\nfunction getTagName(n) {\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n    if (tagName === 'link' && n.attributes._cssText) {\n        tagName = 'style';\n    }\n    return tagName;\n}\nvar CSS_SELECTOR = /([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)/g;\nvar HOVER_SELECTOR = /([^\\\\]):hover/g;\nfunction addHoverClass(cssText) {\n    return cssText.replace(CSS_SELECTOR, function (match, p1, p2) {\n        if (HOVER_SELECTOR.test(p1)) {\n            var newSelector = p1.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n            return p1.replace(/\\s*$/, '') + \", \" + newSelector.replace(/^\\s*/, '') + p2;\n        }\n        else {\n            return match;\n        }\n    });\n}\nfunction buildNode(n, doc) {\n    switch (n.type) {\n        case NodeType.Document:\n            return doc.implementation.createDocument(null, '', null);\n        case NodeType.DocumentType:\n            return doc.implementation.createDocumentType(n.name, n.publicId, n.systemId);\n        case NodeType.Element:\n            var tagName = getTagName(n);\n            var node = void 0;\n            if (n.isSVG) {\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n            }\n            else {\n                node = doc.createElement(tagName);\n            }\n            for (var name in n.attributes) {\n                if (n.attributes.hasOwnProperty(name) && !name.startsWith('rr_')) {\n                    var value = n.attributes[name];\n                    value = typeof value === 'boolean' ? '' : value;\n                    var isTextarea = tagName === 'textarea' && name === 'value';\n                    var isRemoteCss = tagName === 'style' && name === '_cssText';\n                    if (isRemoteCss) {\n                        value = addHoverClass(value);\n                    }\n                    if (isTextarea || isRemoteCss) {\n                        var child = doc.createTextNode(value);\n                        node.appendChild(child);\n                        continue;\n                    }\n                    if (tagName === 'iframe' && name === 'src') {\n                        continue;\n                    }\n                    try {\n                        node.setAttribute(name, value);\n                    }\n                    catch (error) {\n                    }\n                }\n                else {\n                    if (n.attributes.rr_width) {\n                        node.style.width = n.attributes.rr_width;\n                    }\n                    if (n.attributes.rr_height) {\n                        node.style.height = n.attributes\n                            .rr_height;\n                    }\n                }\n            }\n            return node;\n        case NodeType.Text:\n            return doc.createTextNode(n.isStyle ? addHoverClass(n.textContent) : n.textContent);\n        case NodeType.CDATA:\n            return doc.createCDATASection(n.textContent);\n        case NodeType.Comment:\n            return doc.createComment(n.textContent);\n        default:\n            return null;\n    }\n}\nfunction buildNodeWithSN(n, doc, map, skipChild) {\n    if (skipChild === void 0) { skipChild = false; }\n    var node = buildNode(n, doc);\n    if (!node) {\n        return null;\n    }\n    if (n.type === NodeType.Document) {\n        doc.close();\n        doc.open();\n        node = doc;\n    }\n    node.__sn = n;\n    map[n.id] = node;\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\n        !skipChild) {\n        for (var _i = 0, _a = n.childNodes; _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var childNode = buildNodeWithSN(childN, doc, map);\n            if (!childNode) {\n                console.warn('Failed to rebuild', childN);\n            }\n            else {\n                node.appendChild(childNode);\n            }\n        }\n    }\n    return node;\n}\nfunction rebuild(n, doc) {\n    var idNodeMap = {};\n    return [buildNodeWithSN(n, doc, idNodeMap), idNodeMap];\n}\n\nexport { snapshot, serializeNodeWithId, resetId, rebuild, buildNodeWithSN, NodeType };\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n} from './types';\nimport { INode } from 'rrweb-snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport const mirror: Mirror = {\n  map: {},\n  getId(n) {\n    // if n is not a serialized INode, use -1 as its id.\n    if (!n.__sn) {\n      return -1;\n    }\n    return n.__sn.id;\n  },\n  getNode(id) {\n    return mirror.map[id] || null;\n  },\n  // TODO: use a weakmap to get rid of manually memory management\n  removeNodeFromMap(n) {\n    const id = n.__sn && n.__sn.id;\n    delete mirror.map[id];\n    if (n.childNodes) {\n      n.childNodes.forEach(child =>\n        mirror.removeNodeFromMap((child as Node) as INode),\n      );\n    }\n  },\n  has(id) {\n    return mirror.map.hasOwnProperty(id);\n  },\n};\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function () {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait / 50 - (now - previous);\n    let context = this;\n    let args = arguments;\n    if (remaining <= 0 || remaining > wait / 50) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n): hookResetter {\n  const original = Object.getOwnPropertyDescriptor(target, key);\n  Object.defineProperty(target, key, {\n    set(value) {\n      // put hooked setter into event loop to avoid of set latency\n      setTimeout(() => {\n        d.set!.call(this, value);\n      }, 0);\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    },\n  });\n  return () => hookSetter(target, key, original || {});\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nconst BLOCK_CLASS = 'rr-block';\nexport function isBlocked(node: Node | null): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    return (\n      (node as HTMLElement).classList.contains(BLOCK_CLASS) ||\n      isBlocked(node.parentNode)\n    );\n  }\n  return isBlocked(node.parentNode);\n}\n\nexport function isAncestorRemoved(target: INode): boolean {\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode);\n}\n","import { serializedNodeWithId, idNodeMap, INode } from 'rrweb-snapshot';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source: IncrementalSource.MouseMove;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimention;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type recordOptions = {\n  emit?: (e: eventWithTime, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  previousId: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\ntype mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (p: mousePosition[]) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove,\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type viewportResizeDimention = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimention) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: Boolean;\n  showWarning: Boolean;\n  showDebug: Boolean;\n};\n\nexport type playerMetaData = {\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n}\n","import { INode, serializeNodeWithId } from 'rrweb-snapshot';\nimport {\n  mirror,\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isAncestorRemoved,\n} from '../utils';\nimport {\n  mutationCallBack,\n  removedNodeMutation,\n  addedNodeMutation,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  textCursor,\n  attributeCursor,\n} from '../types';\nimport { deepDelete, isParentRemoved, isParentDropped } from './collection';\n\n/**\n * Mutation observer will merge several mutations into an array and pass\n * it to the callback function, this may make tracing added nodes hard.\n * For example, if we append an element el_1 into body, and then append\n * another element el_2 into el_1, these two mutations may be passed to the\n * callback function together when the two operations were done.\n * Generally we need trace child nodes of newly added node, but in this\n * case if we count el_2 as el_1's child node in the first mutation record,\n * then we will count el_2 again in the secoond mutation record which was\n * duplicated.\n * To avoid of duplicate counting added nodes, we will use a Set to store\n * added nodes and its child nodes during iterate mutation records. Then\n * collect added nodes from the Set which will has no duplicate copy. But\n * this also cause newly added node will not be serialized with id ASAP,\n * which means all the id related calculation should be lazy too.\n * @param cb mutationCallBack\n */\nfunction initMutationObserver(cb: mutationCallBack): MutationObserver {\n  const observer = new MutationObserver(mutations => {\n    const texts: textCursor[] = [];\n    const attributes: attributeCursor[] = [];\n    const removes: removedNodeMutation[] = [];\n    const adds: addedNodeMutation[] = [];\n\n    const addsSet = new Set<Node>();\n    const droppedSet = new Set<Node>();\n\n    const genAdds = (n: Node) => {\n      if (isBlocked(n)) {\n        return;\n      }\n      addsSet.add(n);\n      droppedSet.delete(n);\n      n.childNodes.forEach(childN => genAdds(childN));\n    };\n    mutations.forEach(mutation => {\n      const {\n        type,\n        target,\n        oldValue,\n        addedNodes,\n        removedNodes,\n        attributeName,\n      } = mutation;\n      switch (type) {\n        case 'characterData': {\n          const value = target.textContent;\n          if (!isBlocked(target) && value !== oldValue) {\n            texts.push({\n              value,\n              node: target,\n            });\n          }\n          break;\n        }\n        case 'attributes': {\n          const value = (target as HTMLElement).getAttribute(attributeName!);\n          if (isBlocked(target) || value === oldValue) {\n            return;\n          }\n          let item: attributeCursor | undefined = attributes.find(\n            a => a.node === target,\n          );\n          if (!item) {\n            item = {\n              node: target,\n              attributes: {},\n            };\n            attributes.push(item);\n          }\n          // overwrite attribute if the mutations was triggered in same time\n          item.attributes[attributeName!] = value;\n          break;\n        }\n        case 'childList': {\n          addedNodes.forEach(n => genAdds(n));\n          removedNodes.forEach(n => {\n            const nodeId = mirror.getId(n as INode);\n            const parentId = mirror.getId(target as INode);\n            if (isBlocked(n)) {\n              return;\n            }\n            // removed node has not been serialized yet, just remove it from the Set\n            if (addsSet.has(n)) {\n              deepDelete(addsSet, n);\n              droppedSet.add(n);\n            } else if (addsSet.has(target) && nodeId === -1) {\n              /**\n               * If target was newly added and removed child node was\n               * not serialized, it means the child node has been removed\n               * before callback fired, so we can ignore it.\n               * TODO: verify this\n               */\n            } else if (isAncestorRemoved(target as INode)) {\n              /**\n               * If parent id was not in the mirror map any more, it\n               * means the parent node has already been removed. So\n               * the node is also removed which we do not need to track\n               * and replay.\n               */\n            } else {\n              removes.push({\n                parentId,\n                id: nodeId,\n              });\n            }\n            mirror.removeNodeFromMap(n as INode);\n          });\n          break;\n        }\n        default:\n          break;\n      }\n    });\n\n    Array.from(addsSet).forEach(n => {\n      if (!isParentDropped(droppedSet, n) && !isParentRemoved(removes, n)) {\n        adds.push({\n          parentId: mirror.getId((n.parentNode as Node) as INode),\n          previousId: !n.previousSibling\n            ? n.previousSibling\n            : mirror.getId(n.previousSibling as INode),\n          nextId: !n.nextSibling\n            ? n.nextSibling\n            : mirror.getId(n.nextSibling as INode),\n          node: serializeNodeWithId(n, document, mirror.map, true)!,\n        });\n      } else {\n        droppedSet.add(n);\n      }\n    });\n\n    const payload = {\n      texts: texts\n        .map(text => ({\n          id: mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter(text => mirror.has(text.id)),\n      attributes: attributes\n        .map(attribute => ({\n          id: mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter(attribute => mirror.has(attribute.id)),\n      removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n    cb(payload);\n  });\n  observer.observe(document, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMousemoveObserver(cb: mousemoveCallBack): listenerHandler {\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(() => {\n    const totalOffset = Date.now() - timeBaseline!;\n    cb(\n      positions.map(p => {\n        p.timeOffset -= totalOffset;\n        return p;\n      }),\n    );\n    positions = [];\n    timeBaseline = null;\n  }, 500);\n  const updatePosition = throttle<MouseEvent>(\n    evt => {\n      const { clientX, clientY, target } = evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb();\n    },\n    50,\n    {\n      trailing: false,\n    },\n  );\n  return on('mousemove', updatePosition);\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n): listenerHandler {\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent) => {\n      if (isBlocked(event.target as Node)) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = event;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(key => Number.isNaN(Number(key)))\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler));\n    });\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\n\nfunction initScrollObserver(cb: scrollCallback): listenerHandler {\n  const updatePosition = throttle<UIEvent>(evt => {\n    if (!evt.target || isBlocked(evt.target as Node)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === document) {\n      const scrollEl = (document.scrollingElement || document.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    cb({\n      width: Number(width),\n      height: Number(height),\n    });\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst HOOK_PROPERTIES: Array<[HTMLElement, string]> = [\n  [HTMLInputElement.prototype, 'value'],\n  [HTMLInputElement.prototype, 'checked'],\n  [HTMLSelectElement.prototype, 'value'],\n  [HTMLTextAreaElement.prototype, 'value'],\n];\nconst IGNORE_CLASS = 'rr-ignore';\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(cb: inputCallback): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(IGNORE_CLASS)\n    ) {\n      return;\n    }\n    const text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      document\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach(el => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const handlers: Array<listenerHandler | hookResetter> = [\n    'input',\n    'change',\n  ].map(eventName => on(eventName, eventHandler));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...HOOK_PROPERTIES.map(p =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\n\nexport default function initObservers(o: observerParam): listenerHandler {\n  const mutationObserver = initMutationObserver(o.mutationCb);\n  const mousemoveHandler = initMousemoveObserver(o.mousemoveCb);\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n  );\n  const scrollHandler = initScrollObserver(o.scrollCb);\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(o.inputCb);\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n  };\n}\n","/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\n\nimport { INode } from 'rrweb-snapshot';\nimport { removedNodeMutation } from '../types';\nimport { mirror } from '../utils';\n\nexport function deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach(childN => deepDelete(addsSet, childN));\n}\n\nexport function isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some(r => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode);\n}\n\nexport function isParentDropped(droppedSet: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (droppedSet.has(parentNode)) {\n    return true;\n  }\n  return isParentDropped(droppedSet, parentNode);\n}\n","import { snapshot } from 'rrweb-snapshot';\nimport initObservers from './observer';\nimport { mirror, on, getWindowWidth, getWindowHeight } from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n} from '../types';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nfunction record(options: recordOptions = {}): listenerHandler | undefined {\n  const { emit, checkoutEveryNms, checkoutEveryNth } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  const wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    emit(e, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  function takeFullSnapshot(isCheckout = false) {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n    const [node, idNodeMap] = snapshot(document);\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left: document.documentElement!.scrollLeft,\n            top: document.documentElement!.scrollTop,\n          },\n        },\n      }),\n    );\n  }\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n    const init = () => {\n      takeFullSnapshot();\n\n      handlers.push(\n        initObservers({\n          mutationCb: m =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Mutation,\n                  ...m,\n                },\n              }),\n            ),\n          mousemoveCb: positions =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseMove,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: d =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: p =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Scroll,\n                  ...p,\n                },\n              }),\n            ),\n          viewportResizeCb: d =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: v =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n        }),\n      );\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach(h => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nexport default record;\n","//      \n// An event handler can take an optional event argument\n// and should not return a value\n                                          \n                                                               \n\n// An array of all currently registered event handlers for a type\n                                            \n                                                            \n// A map of event types and their corresponding event handlers.\n                        \n                                 \n                                   \n  \n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\nfunction mitt(all                 ) {\n\tall = all || Object.create(null);\n\n\treturn {\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to listen for, or `\"*\"` for all events\n\t\t * @param  {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton: function on(type        , handler              ) {\n\t\t\t(all[type] || (all[type] = [])).push(handler);\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to unregister `handler` from, or `\"*\"`\n\t\t * @param  {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff: function off(type        , handler              ) {\n\t\t\tif (all[type]) {\n\t\t\t\tall[type].splice(all[type].indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * @param {String} type  The event type to invoke\n\t\t * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit: function emit(type        , evt     ) {\n\t\t\t(all[type] || []).slice().map(function (handler) { handler(evt); });\n\t\t\t(all['*'] || []).slice().map(function (handler) { handler(type, evt); });\n\t\t}\n\t};\n}\n\nexport default mitt;\n//# sourceMappingURL=mitt.es.js.map\n","/* smoothscroll v0.4.0 - 2018 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      var isBody;\n\n      do {\n        el = el.parentNode;\n\n        isBody = el === d.body;\n      } while (isBody === false && isScrollable(el) === false);\n\n      isBody = null;\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","import { playerConfig, actionWithDelay } from '../types';\n\nexport default class Timer {\n  public timeOffset: number = 0;\n\n  private actions: actionWithDelay[];\n  private config: playerConfig;\n  private raf: number;\n\n  constructor(config: playerConfig, actions: actionWithDelay[] = []) {\n    this.actions = actions;\n    this.config = config;\n  }\n  /**\n   * Add an action after the timer starts.\n   * @param action\n   */\n  public addAction(action: actionWithDelay) {\n    const index = this.findActionIndex(action);\n    this.actions.splice(index, 0, action);\n  }\n  /**\n   * Add all actions before the timer starts\n   * @param actions\n   */\n  public addActions(actions: actionWithDelay[]) {\n    this.actions.push(...actions);\n  }\n\n  public start() {\n    this.actions.sort((a1, a2) => a1.delay - a2.delay);\n    this.timeOffset = 0;\n    let lastTimestamp = performance.now();\n    const { actions, config } = this;\n    const self = this;\n    function check(time: number) {\n      self.timeOffset += (time - lastTimestamp) * config.speed;\n      lastTimestamp = time;\n      while (actions.length) {\n        const action = actions[0];\n        if (self.timeOffset >= action.delay) {\n          actions.shift();\n          action.doAction();\n        } else {\n          break;\n        }\n      }\n      if (actions.length > 0) {\n        self.raf = requestAnimationFrame(check);\n      }\n    }\n    this.raf = requestAnimationFrame(check);\n  }\n\n  public clear() {\n    if (this.raf) {\n      cancelAnimationFrame(this.raf);\n    }\n    this.actions.length = 0;\n  }\n\n  private findActionIndex(action: actionWithDelay): number {\n    let start = 0;\n    let end = this.actions.length - 1;\n    while (start <= end) {\n      let mid = Math.floor((start + end) / 2);\n      if (this.actions[mid].delay < action.delay) {\n        start = mid + 1;\n      } else if (this.actions[mid].delay > action.delay) {\n        end = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return start;\n  }\n}\n","const rules: string[] = [\n  'iframe, .rr-block { background: #ccc }',\n  'noscript { display: none !important; }',\n];\n\nexport default rules;\n","import { rebuild, buildNodeWithSN } from 'rrweb-snapshot';\nimport * as mittProxy from 'mitt';\nimport * as smoothscroll from 'smoothscroll-polyfill';\nimport Timer from './timer';\nimport {\n  EventType,\n  IncrementalSource,\n  fullSnapshotEvent,\n  eventWithTime,\n  MouseInteractions,\n  playerConfig,\n  playerMetaData,\n  viewportResizeDimention,\n  missingNodeMap,\n  addedNodeMutation,\n  missingNode,\n  actionWithDelay,\n  incrementalSnapshotEvent,\n  incrementalData,\n  ReplayerEvents,\n} from '../types';\nimport { mirror } from '../utils';\nimport injectStyleRules from './styles/inject-style';\nimport './styles/style.css';\n\nconst SKIP_TIME_THRESHOLD = 10 * 1000;\nconst SKIP_TIME_INTERVAL = 5 * 1000;\n\nsmoothscroll.polyfill();\n\n// https://github.com/rollup/rollup/issues/1267#issuecomment-296395734\n// tslint:disable-next-line\nconst mitt = (mittProxy as any).default || mittProxy;\n\nconst REPLAY_CONSOLE_PREFIX = '[replayer]';\n\nexport class Replayer {\n  public wrapper: HTMLDivElement;\n  public iframe: HTMLIFrameElement;\n\n  public timer: Timer;\n\n  private events: eventWithTime[] = [];\n  private config: playerConfig;\n\n  private mouse: HTMLDivElement;\n\n  private emitter: mitt.Emitter = mitt();\n\n  private baselineTime: number = 0;\n  // record last played event timestamp when paused\n  private lastPlayedEvent: eventWithTime;\n\n  private nextUserInteractionEvent: eventWithTime | null;\n  private noramlSpeed: number = -1;\n\n  private missingNodeRetryMap: missingNodeMap = {};\n\n  constructor(events: eventWithTime[], config?: Partial<playerConfig>) {\n    if (events.length < 2) {\n      throw new Error('Replayer need at least 2 events.');\n    }\n    this.events = events;\n    this.handleResize = this.handleResize.bind(this);\n\n    const defaultConfig: playerConfig = {\n      speed: 1,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      showWarning: true,\n      showDebug: false,\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n\n    this.timer = new Timer(this.config);\n    this.setupDom();\n    this.emitter.on('resize', this.handleResize as mitt.Handler);\n  }\n\n  public on(event: string, handler: mitt.Handler) {\n    this.emitter.on(event, handler);\n  }\n\n  public setConfig(config: Partial<playerConfig>) {\n    Object.keys(config).forEach((key: keyof playerConfig) => {\n      this.config[key] = config[key]!;\n    });\n    if (!this.config.skipInactive) {\n      this.noramlSpeed = -1;\n    }\n  }\n\n  public getMetaData(): playerMetaData {\n    const firstEvent = this.events[0];\n    const lastEvent = this.events[this.events.length - 1];\n    return {\n      totalTime: lastEvent.timestamp - firstEvent.timestamp,\n    };\n  }\n\n  public getTimeOffset(): number {\n    return this.baselineTime - this.events[0].timestamp;\n  }\n\n  /**\n   * This API was designed to be used as play at any time offset.\n   * Since we minimized the data collected from recorder, we do not\n   * have the ability of undo an event.\n   * So the implementation of play at any time offset will always iterate\n   * all of the events, cast event before the offset synchronously\n   * and cast event after the offset asynchronously with timer.\n   * @param timeOffset number\n   */\n  public play(timeOffset = 0) {\n    this.timer.clear();\n    this.baselineTime = this.events[0].timestamp + timeOffset;\n    const actions = new Array<actionWithDelay>();\n    for (const event of this.events) {\n      const isSync = event.timestamp < this.baselineTime;\n      const castFn = this.getCastFn(event, isSync);\n      if (isSync) {\n        castFn();\n      } else {\n        actions.push({ doAction: castFn, delay: this.getDelay(event) });\n      }\n    }\n    this.timer.addActions(actions);\n    this.timer.start();\n    this.emitter.emit(ReplayerEvents.Start);\n  }\n\n  public pause() {\n    this.timer.clear();\n    this.emitter.emit(ReplayerEvents.Pause);\n  }\n\n  public resume(timeOffset = 0) {\n    this.timer.clear();\n    this.baselineTime = this.events[0].timestamp + timeOffset;\n    const actions = new Array<actionWithDelay>();\n    for (const event of this.events) {\n      if (\n        event.timestamp <= this.lastPlayedEvent.timestamp ||\n        event === this.lastPlayedEvent\n      ) {\n        continue;\n      }\n      const castFn = this.getCastFn(event);\n      actions.push({\n        doAction: castFn,\n        delay: this.getDelay(event),\n      });\n    }\n    this.timer.addActions(actions);\n    this.timer.start();\n    this.emitter.emit(ReplayerEvents.Resume);\n  }\n\n  private setupDom() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.classList.add('replayer-wrapper');\n    this.config.root.appendChild(this.wrapper);\n\n    this.mouse = document.createElement('div');\n    this.mouse.classList.add('replayer-mouse');\n    this.wrapper.appendChild(this.mouse);\n\n    this.iframe = document.createElement('iframe');\n    this.iframe.setAttribute('sandbox', 'allow-same-origin');\n    this.iframe.setAttribute('scrolling', 'no');\n    this.wrapper.appendChild(this.iframe);\n  }\n\n  private handleResize(dimension: viewportResizeDimention) {\n    this.iframe.width = `${dimension.width}px`;\n    this.iframe.height = `${dimension.height}px`;\n  }\n\n  // TODO: add speed to mouse move timestamp calculation\n  private getDelay(event: eventWithTime): number {\n    // Mouse move events was recorded in a throttle function,\n    // so we need to find the real timestamp by traverse the time offsets.\n    if (\n      event.type === EventType.IncrementalSnapshot &&\n      event.data.source === IncrementalSource.MouseMove\n    ) {\n      const firstOffset = event.data.positions[0].timeOffset;\n      // timeOffset is a negative offset to event.timestamp\n      const firstTimestamp = event.timestamp + firstOffset;\n      event.delay = firstTimestamp - this.baselineTime;\n      return firstTimestamp - this.baselineTime;\n    }\n    event.delay = event.timestamp - this.baselineTime;\n    return event.timestamp - this.baselineTime;\n  }\n\n  private getCastFn(event: eventWithTime, isSync = false) {\n    let castFn: undefined | (() => void);\n    switch (event.type) {\n      case EventType.DomContentLoaded:\n      case EventType.Load:\n        break;\n      case EventType.Meta:\n        castFn = () =>\n          this.emitter.emit(ReplayerEvents.Resize, {\n            width: event.data.width,\n            height: event.data.height,\n          });\n        break;\n      case EventType.FullSnapshot:\n        castFn = () => {\n          this.rebuildFullSnapshot(event);\n          this.iframe.contentWindow!.scrollTo(event.data.initialOffset);\n        };\n        break;\n      case EventType.IncrementalSnapshot:\n        castFn = () => {\n          this.applyIncremental(event, isSync);\n          if (event === this.nextUserInteractionEvent) {\n            this.nextUserInteractionEvent = null;\n            this.restoreSpeed();\n          }\n          if (this.config.skipInactive && !this.nextUserInteractionEvent) {\n            for (const _event of this.events) {\n              if (_event.timestamp! <= event.timestamp!) {\n                continue;\n              }\n              if (this.isUserInteraction(_event)) {\n                if (\n                  _event.delay! - event.delay! >\n                  SKIP_TIME_THRESHOLD * this.config.speed\n                ) {\n                  this.nextUserInteractionEvent = _event;\n                }\n                break;\n              }\n            }\n            if (this.nextUserInteractionEvent) {\n              this.noramlSpeed = this.config.speed;\n              const skipTime =\n                this.nextUserInteractionEvent.delay! - event.delay!;\n              const payload = {\n                speed: Math.min(Math.round(skipTime / SKIP_TIME_INTERVAL), 360),\n              };\n              this.setConfig(payload);\n              this.emitter.emit(ReplayerEvents.SkipStart, payload);\n            }\n          }\n        };\n        break;\n      default:\n    }\n    const wrappedCastFn = () => {\n      if (castFn) {\n        castFn();\n      }\n      this.lastPlayedEvent = event;\n      if (event === this.events[this.events.length - 1]) {\n        this.restoreSpeed();\n        this.emitter.emit(ReplayerEvents.Finish);\n      }\n    };\n    return wrappedCastFn;\n  }\n\n  private rebuildFullSnapshot(\n    event: fullSnapshotEvent & { timestamp: number },\n  ) {\n    if (Object.keys(this.missingNodeRetryMap).length) {\n      console.warn(\n        'Found unresolved missing node map',\n        this.missingNodeRetryMap,\n      );\n    }\n    this.missingNodeRetryMap = {};\n    mirror.map = rebuild(event.data.node, this.iframe.contentDocument!)[1];\n    const styleEl = document.createElement('style');\n    const { documentElement, head } = this.iframe.contentDocument!;\n    documentElement!.insertBefore(styleEl, head);\n    for (let idx = 0; idx < injectStyleRules.length; idx++) {\n      (styleEl.sheet! as CSSStyleSheet).insertRule(injectStyleRules[idx], idx);\n    }\n    this.emitter.emit(ReplayerEvents.FullsnapshotRebuilded);\n    this.waitForStylesheetLoad();\n  }\n\n  /**\n   * pause when loading style sheet, resume when loaded all timeout exceed\n   */\n  private waitForStylesheetLoad() {\n    const { head } = this.iframe.contentDocument!;\n    if (head) {\n      const unloadSheets: Set<HTMLLinkElement> = new Set();\n      let timer: number;\n      head\n        .querySelectorAll('link[rel=\"stylesheet\"]')\n        .forEach((css: HTMLLinkElement) => {\n          if (!css.sheet) {\n            if (unloadSheets.size === 0) {\n              this.pause();\n              this.emitter.emit(ReplayerEvents.LoadStylesheetStart);\n              timer = window.setTimeout(() => {\n                this.resume();\n                // mark timer was called\n                timer = -1;\n              }, this.config.loadTimeout);\n            }\n            unloadSheets.add(css);\n            css.addEventListener('load', () => {\n              unloadSheets.delete(css);\n              if (unloadSheets.size === 0 && timer !== -1) {\n                this.resume();\n                this.emitter.emit(ReplayerEvents.LoadStylesheetEnd);\n                if (timer) {\n                  window.clearTimeout(timer);\n                }\n              }\n            });\n          }\n        });\n    }\n  }\n\n  private applyIncremental(\n    e: incrementalSnapshotEvent & { timestamp: number },\n    isSync: boolean,\n  ) {\n    const { data: d } = e;\n    switch (d.source) {\n      case IncrementalSource.Mutation: {\n        d.removes.forEach(mutation => {\n          const target = mirror.getNode(mutation.id);\n          if (!target) {\n            return this.warnNodeNotFound(d, mutation.id);\n          }\n          const parent = mirror.getNode(mutation.parentId);\n          if (!parent) {\n            return this.warnNodeNotFound(d, mutation.parentId);\n          }\n          // target may be removed with its parents before\n          mirror.removeNodeFromMap(target);\n          if (parent) {\n            parent.removeChild(target);\n          }\n        });\n\n        const missingNodeMap: missingNodeMap = { ...this.missingNodeRetryMap };\n        d.adds.forEach(mutation => {\n          const target = buildNodeWithSN(\n            mutation.node,\n            this.iframe.contentDocument!,\n            mirror.map,\n            true,\n          ) as Node;\n          const parent = mirror.getNode(mutation.parentId);\n          if (!parent) {\n            return this.warnNodeNotFound(d, mutation.parentId);\n          }\n          let previous: Node | null = null;\n          let next: Node | null = null;\n          if (mutation.previousId) {\n            previous = mirror.getNode(mutation.previousId) as Node;\n          }\n          if (mutation.nextId) {\n            next = mirror.getNode(mutation.nextId) as Node;\n          }\n\n          if (mutation.previousId === -1 || mutation.nextId === -1) {\n            missingNodeMap[mutation.node.id] = {\n              node: target,\n              mutation,\n            };\n            return;\n          }\n\n          if (\n            previous &&\n            previous.nextSibling &&\n            previous.nextSibling.parentNode\n          ) {\n            parent.insertBefore(target, previous.nextSibling);\n          } else if (next && next.parentNode) {\n            parent.insertBefore(target, next);\n          } else {\n            parent.appendChild(target);\n          }\n\n          if (mutation.previousId || mutation.nextId) {\n            this.resolveMissingNode(missingNodeMap, parent, target, mutation);\n          }\n        });\n        if (Object.keys(missingNodeMap).length) {\n          Object.assign(this.missingNodeRetryMap, missingNodeMap);\n        }\n\n        d.texts.forEach(mutation => {\n          const target = mirror.getNode(mutation.id);\n          if (!target) {\n            return this.warnNodeNotFound(d, mutation.id);\n          }\n          target.textContent = mutation.value;\n        });\n        d.attributes.forEach(mutation => {\n          const target = mirror.getNode(mutation.id);\n          if (!target) {\n            return this.warnNodeNotFound(d, mutation.id);\n          }\n          for (const attributeName in mutation.attributes) {\n            if (typeof attributeName === 'string') {\n              const value = mutation.attributes[attributeName];\n              if (value) {\n                ((target as Node) as Element).setAttribute(\n                  attributeName,\n                  value,\n                );\n              } else {\n                ((target as Node) as Element).removeAttribute(attributeName);\n              }\n            }\n          }\n        });\n        break;\n      }\n      case IncrementalSource.MouseMove:\n        // skip mouse move in sync mode\n        if (!isSync) {\n          d.positions.forEach(p => {\n            const action = {\n              doAction: () => {\n                this.moveAndHover(d, p.x, p.y, p.id);\n              },\n              delay: p.timeOffset + e.timestamp - this.baselineTime,\n            };\n            this.timer.addAction(action);\n          });\n        }\n        break;\n      case IncrementalSource.MouseInteraction: {\n        /**\n         * Same as the situation of missing input target.\n         */\n        if (d.id === -1) {\n          break;\n        }\n        const event = new Event(MouseInteractions[d.type].toLowerCase());\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        switch (d.type) {\n          case MouseInteractions.Blur:\n            if (((target as Node) as HTMLElement).blur) {\n              ((target as Node) as HTMLElement).blur();\n            }\n            break;\n          case MouseInteractions.Focus:\n            if (((target as Node) as HTMLElement).focus) {\n              ((target as Node) as HTMLElement).focus({\n                preventScroll: true,\n              });\n            }\n            break;\n          case MouseInteractions.Click:\n            /**\n             * Click has no visual impact when replaying and may\n             * trigger navigation when apply to an <a> link.\n             * So we will not call click(), instead we add an\n             * animation to the mouse element which indicate user\n             * clicked at this moment.\n             */\n            if (!isSync) {\n              this.moveAndHover(d, d.x, d.y, d.id);\n              this.mouse.classList.remove('active');\n              // tslint:disable-next-line\n              void this.mouse.offsetWidth;\n              this.mouse.classList.add('active');\n            }\n            break;\n          default:\n            target.dispatchEvent(event);\n        }\n        break;\n      }\n      case IncrementalSource.Scroll: {\n        /**\n         * Same as the situation of missing input target.\n         */\n        if (d.id === -1) {\n          break;\n        }\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        if ((target as Node) === this.iframe.contentDocument) {\n          this.iframe.contentWindow!.scrollTo({\n            top: d.y,\n            left: d.x,\n            behavior: isSync ? 'auto' : 'smooth',\n          });\n        } else {\n          try {\n            ((target as Node) as Element).scrollTop = d.y;\n            ((target as Node) as Element).scrollLeft = d.x;\n          } catch (error) {\n            /**\n             * Seldomly we may found scroll target was removed before\n             * its last scroll event.\n             */\n          }\n        }\n        break;\n      }\n      case IncrementalSource.ViewportResize:\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width: d.width,\n          height: d.height,\n        });\n        break;\n      case IncrementalSource.Input: {\n        /**\n         * Input event on an unserialized node usually means the event\n         * was synchrony triggered programmatically after the node was\n         * created. This means there was not an user observable interaction\n         * and we do not need to replay it.\n         */\n        if (d.id === -1) {\n          break;\n        }\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        try {\n          ((target as Node) as HTMLInputElement).checked = d.isChecked;\n          ((target as Node) as HTMLInputElement).value = d.text;\n        } catch (error) {\n          // for safe\n        }\n        break;\n      }\n      default:\n    }\n  }\n\n  private resolveMissingNode(\n    map: missingNodeMap,\n    parent: Node,\n    target: Node,\n    targetMutation: addedNodeMutation,\n  ) {\n    const { previousId, nextId } = targetMutation;\n    const previousInMap = previousId && map[previousId];\n    const nextInMap = nextId && map[nextId];\n    if (previousInMap) {\n      const { node, mutation } = previousInMap as missingNode;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.resolveMissingNode(map, parent, node as Node, mutation);\n      }\n    }\n    if (nextInMap) {\n      const { node, mutation } = nextInMap as missingNode;\n      parent.insertBefore(node, target.nextSibling);\n      delete map[mutation.node.id];\n      delete this.missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.resolveMissingNode(map, parent, node as Node, mutation);\n      }\n    }\n  }\n\n  private moveAndHover(d: incrementalData, x: number, y: number, id: number) {\n    this.mouse.style.left = `${x}px`;\n    this.mouse.style.top = `${y}px`;\n    const target = mirror.getNode(id);\n    if (!target) {\n      return this.debugNodeNotFound(d, id);\n    }\n    this.hoverElements((target as Node) as Element);\n  }\n\n  private hoverElements(el: Element) {\n    this.iframe\n      .contentDocument!.querySelectorAll('.\\\\:hover')\n      .forEach(hoveredEl => {\n        hoveredEl.classList.remove(':hover');\n      });\n    let currentEl: Element | null = el;\n    while (currentEl) {\n      currentEl.classList.add(':hover');\n      currentEl = currentEl.parentElement;\n    }\n  }\n\n  private isUserInteraction(event: eventWithTime): boolean {\n    if (event.type !== EventType.IncrementalSnapshot) {\n      return false;\n    }\n    return (\n      event.data.source > IncrementalSource.Mutation &&\n      event.data.source <= IncrementalSource.Input\n    );\n  }\n\n  private restoreSpeed() {\n    if (this.noramlSpeed === -1) {\n      return;\n    }\n    const payload = { speed: this.noramlSpeed };\n    this.setConfig(payload);\n    this.emitter.emit(ReplayerEvents.SkipEnd, payload);\n    this.noramlSpeed = -1;\n  }\n\n  private warnNodeNotFound(d: incrementalData, id: number) {\n    if (!this.config.showWarning) {\n      return;\n    }\n    console.warn(REPLAY_CONSOLE_PREFIX, `Node with id '${id}' not found in`, d);\n  }\n\n  private debugNodeNotFound(d: incrementalData, id: number) {\n    /**\n     * There maybe some valid scenes of node not being found.\n     * Because DOM events are macrotask and MutationObserver callback\n     * is microtask, so events fired on a removed DOM may emit\n     * snapshots in the reverse order.\n     */\n    if (!this.config.showDebug) {\n      return;\n    }\n    // tslint:disable-next-line: no-console\n    console.log(REPLAY_CONSOLE_PREFIX, `Node with id '${id}' not found in`, d);\n  }\n}\n"],"names":["NodeType","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","_id","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","cssText","href","replace","origin","path1","path2","path3","url","filePath","test","indexOf","split","slice","join","stack","parts","pop","_i","parts_1","part","push","absoluteToDoc","doc","attributeValue","a","createElement","BLOCK_CLASS","serializeNode","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","name","publicId","systemId","ELEMENT_NODE","needBlock","classList","contains","tagName","toLowerCase","attributes_1","_a","Array","from","attributes","_b","value","location","stylesheet","styleSheets","find","rules","cssRules","reduce","prev","cur","error","getCssRulesString","_cssText","checked","selectValue","parentElement","selected","_c","getBoundingClientRect","width","height","rr_width","rr_height","Element","isSVG","el","SVGElement","undefined","TEXT_NODE","parentTagName","parentNode","textContent","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNodeWithId","map","skipChild","_serializedNode","console","warn","serializedNode","id","__sn","recordChild","serializedChildNode","snapshot","idNodeMap","tagMap","script","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","CSS_SELECTOR","HOVER_SELECTOR","addHoverClass","match","p1","p2","newSelector","buildNode","implementation","createDocument","createDocumentType","getTagName","node","createElementNS","startsWith","isTextarea","isRemoteCss","child","createTextNode","appendChild","setAttribute","style","createCDATASection","createComment","buildNodeWithSN","close","open","childN","childNode","on","fn","target","options","capture","passive","addEventListener","removeEventListener","mirror","getId","getNode","removeNodeFromMap","forEach","has","throttle","func","wait","timeout","previous","now","Date","leading","remaining","context","args","window","clearTimeout","trailing","setTimeout","getWindowHeight","innerHeight","document","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","EventType","IncrementalSource","MouseInteractions","ReplayerEvents","isBlocked","initMutationObserver","cb","observer","MutationObserver","mutations","texts","removes","adds","addsSet","Set","droppedSet","genAdds","add","mutation","oldValue","addedNodes","removedNodes","attributeName","getAttribute","item","nodeId","parentId","deepDelete","isAncestorRemoved","isParentDropped","isParentRemoved","some","r","previousId","previousSibling","nextId","nextSibling","payload","text","filter","attribute","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","initMouseInteractionObserver","handlers","keys","key","Number","isNaN","eventKey","eventName","handler","event","clientX","clientY","x","y","getHandler","h","INPUT_TAGS","HOOK_PROPERTIES","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","IGNORE_CLASS","lastInputValueMap","WeakMap","initInputObserver","eventHandler","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","get","set","propertyDescriptor","getOwnPropertyDescriptor","hookSetter","d","original","defineProperty","_this","initObservers","o","timeBaseline","positions","wrappedCb","mutationObserver","mutationCb","mousemoveHandler","mousemoveCb","totalOffset","timeOffset","evt","mouseInteractionHandler","mouseInteractionCb","scrollHandler","scrollEl","scrollingElement","scrollLeft","scrollTop","initScrollObserver","scrollCb","viewportResizeHandler","initViewportResizeObserver","viewportResizeCb","inputHandler","inputCb","disconnect","wrapEvent","e","timestamp","mitt","all","create","off","splice","emit","module","polyfill","w","__forceSmoothScrollPolyfill__","userAgent","HTMLElement","SCROLL_TIME","scroll","scrollTo","scrollBy","elementScroll","scrollElement","scrollIntoView","performance","bind","ROUNDING_TOLERANCE","navigator","RegExp","shouldBailOut","smoothScroll","left","scrollX","pageXOffset","top","scrollY","pageYOffset","SyntaxError","behavior","scrollableParent","isBody","isScrollable","findScrollableParent","parentRects","clientRects","getComputedStyle","position","firstArg","TypeError","hasScrollableSpace","axis","scrollHeight","scrollWidth","canOverflow","overflowValue","isScrollableY","isScrollableX","step","currentX","currentY","k","elapsed","startTime","Math","cos","PI","startX","startY","method","scrollable","requestAnimationFrame","config","actions","Timer","action","index","findActionIndex","sort","a1","a2","delay","lastTimestamp","self","raf","check","time","speed","shift","doAction","cancelAnimationFrame","start","end","mid","floor","mittProxy[\"default\"]","mittProxy","events","Error","handleResize","defaultConfig","root","loadTimeout","skipInactive","showWarning","showDebug","timer","setupDom","emitter","Replayer","noramlSpeed","firstEvent","totalTime","baselineTime","clear","isSync","castFn","getCastFn","getDelay","addActions","Start","Pause","lastPlayedEvent","Resume","wrapper","mouse","iframe","dimension","IncrementalSnapshot","data","source","MouseMove","firstOffset","firstTimestamp","DomContentLoaded","Load","Meta","Resize","FullSnapshot","rebuildFullSnapshot","contentWindow","initialOffset","applyIncremental","nextUserInteractionEvent","restoreSpeed","_event","isUserInteraction","skipTime","min","round","setConfig","SkipStart","Finish","missingNodeRetryMap","contentDocument","styleEl","head","insertBefore","idx","injectStyleRules","sheet","insertRule","FullsnapshotRebuilded","waitForStylesheetLoad","timer_1","unloadSheets_1","css","size","pause","LoadStylesheetStart","resume","LoadStylesheetEnd","Mutation","warnNodeNotFound","parent","removeChild","missingNodeMap_1","next","resolveMissingNode","removeAttribute","moveAndHover","addAction","MouseInteraction","Event","debugNodeNotFound","Blur","blur","Focus","focus","preventScroll","Click","remove","offsetWidth","dispatchEvent","Scroll","ViewportResize","Input","targetMutation","previousInMap","nextInMap","hoverElements","hoveredEl","currentEl","SkipEnd","log","lastFullSnapshotEvent","checkoutEveryNms","checkoutEveryNth","incrementalSnapshotCount","wrappedEmit","isCheckout","exceedCount","exceedTime","takeFullSnapshot","handlers_1","init_1","m","readyState"],"mappings":"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"}